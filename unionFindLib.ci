module unionFindLib {
    extern module prefixBalance;

    include "types.h";

    readonly CProxy_UnionFindLib _UfLibProxy;
    readonly CProxy_Prefix prefixLibArray;
    readonly CkGroupID libGroupID;
    readonly CProxy_UnionFindLibCache _UfLibProxyCache;
    readonly CkCallback initDoneCacheCb;
    //readonly CkCallback libProxyDoneCb;

    nodegroup UnionFindLibCache {
      // entry void UnionFindLibCacheInit(CkCallback cb);
      entry [reductiontarget] void initDoneCache();
      entry UnionFindLibCache();
      entry void initOffsets(CkCallback _libcb);
      entry [reductiontarget] void doneOffsets(std::vector<int64_t> result);
      entry [reductiontarget] void callWork();
    }

    group UnionFindLib {
        entry UnionFindLib();
        // function to register Phase 1 callback
        entry void register_phase_one_cb(CkCallback cb);
        // functions to build inverted trees
        entry void anchor(int64_t w_arrIdx, int64_t v, int64_t path_base_arrIdx);
        // function for grandparent short-circuiting

        // functions to perform distributed connected components
        entry void find_components(CkCallback cb);
        entry void inter_start_component_labeling(CkCallback cb);
        entry void need_boss(int64_t arrIdx, int64_t fromID);
        entry void set_component(int64_t arrIdx, int64_t compNum);

        // functions to prune out small components
        entry void prune_components(int64_t threshold, CkCallback cb);
        entry [reductiontarget] void perform_pruning();
        //entry [reductiontarget,nokeep] void merge_count_results(CkReductionMsg *msg);
        //entry [reductiontarget] void merge_count_results(int64_t totalCounts[numElems], int64_t numElems);

        // TRAM functions
        entry [aggregate] void insertDataFindBoss(const findBossData & data);
        entry [aggregate] void insertDataNeedBoss(const uint64_t & data);
        entry [aggregate] void insertDataAnchor(const anchorData & data);
        // entry [inline, aggregate] void insertDataAnchor(const anchorData & data);
#ifdef PROFILING
        entry [reductiontarget] void profiling_count_max(long maxCount);
#endif
        entry void recv_reqs_processed();
        entry void register_batch_cb(CkCallback cb);
        
        // entry [aggregate] void need_label(int64_t req_vertex, int64_t parent_arrID);
        entry [aggregate] void need_label(needRootData data);
        entry void recv_label(int64_t recv_vertex_arrID, int64_t labelID);
        entry [reductiontarget] void total_components(int64_t nComponents);
        
        entry [aggregate] void inter_need_label(needRootData data);
        entry void inter_recv_label(int64_t recv_vertex_arrID, int64_t labelID);
        entry [reductiontarget] void inter_total_components(int64_t nComponents);
        entry [reductiontarget] void done_prepare_for_component_labeling();
        entry void prepare_for_component_labeling(CkCallback cb);

        entry [reductiontarget] void doneProxyCreation();

    }

    // group chare to support the library chares
    group UnionFindLibGroup {
        entry UnionFindLibGroup();
        entry [reductiontarget] void build_component_count_array(int64_t totalCounts[numElems], int64_t numElems);
        entry [reductiontarget] void done_profiling(int64_t result);
        entry void contribute_count();
    }
};
